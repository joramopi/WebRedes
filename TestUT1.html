<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evaluación Interactiva - Unidad 1</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome para iconos -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        /* Transiciones de Vue */
        .fade-enter-active, .fade-leave-active {
            transition: opacity 0.3s ease;
        }
        .fade-enter-from, .fade-leave-to {
            opacity: 0;
        }
        /* Estilos para ocultar visualmente pero mantener accesible */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="app" class="flex flex-col lg:flex-row min-h-screen">
        <!-- Sidebar Navigation -->
        <div class="sidebar w-full lg:w-64 text-white p-4 bg-[#2d6073] flex-shrink-0">
            <div class="flex items-center justify-center lg:justify-start mb-8 pt-2">
                <div class="bg-white p-2 rounded-full">
                    <i class="fas fa-network-wired text-2xl text-[#2d6073]"></i>
                </div>
                <h1 class="text-xl ml-3 font-bold">CC-0601</h1>
            </div>
            
            <nav>
                <div class="mb-4 text-sm text-gray-300 uppercase tracking-wider pl-4">Navegación</div>
                <a href="index.html" class="menu-item flex items-center py-3 px-4 rounded-lg mb-1 bg-[#3a738c]">
                    <i class="fas fa-home mr-3"></i>
                    <span>Volver al Inicio</span>
                </a>
                <a href="UT1.html" class="menu-item flex items-center py-3 px-4 rounded-lg mb-1">
                    <i class="fas fa-arrow-left mr-3"></i>
                    <span>Volver a la Unidad 1</span>
                </a>
                
                <div class="mt-8 pt-4 border-t border-[#2d6073]">
                    <div class="text-sm text-gray-400 mb-2">Otras evaluaciones:</div>
                    <a href="#" class="block py-2 px-4 text-sm text-gray-300 hover:bg-[#3a738c] rounded-lg mb-1 flex items-center">
                        <i class="fas fa-tasks mr-2 w-4 text-center"></i>
                        Test Unidad 2
                    </a>
                    <a href="#" class="block py-2 px-4 text-sm text-gray-300 hover:bg-[#3a738c] rounded-lg mb-1 flex items-center">
                        <i class="fas fa-tasks mr-2 w-4 text-center"></i>
                        Test Unidad 3
                    </a>
                    <a href="#" class="block py-2 px-4 text-sm text-gray-300 hover:bg-[#3a738c] rounded-lg flex items-center">
                        <i class="fas fa-tasks mr-2 w-4 text-center"></i>
                        Test Unidad 4
                    </a>
                </div>

                <!-- Opciones de Quiz (Solo para depuración o configuración) -->
                <div class="mt-8 pt-4 border-t border-[#2d6073]">
                    <div class="text-sm text-gray-400 mb-2">Configuración del Quiz:</div>
                    <label class="flex items-center text-gray-300 py-2 px-4 text-sm mb-1">
                        <input type="checkbox" v-model="randomizeQuestions" class="h-4 w-4 text-[#4787a4] rounded border-gray-300 mr-2">
                        <span>Preguntas aleatorias</span>
                    </label>
                    <label class="flex items-center text-gray-300 py-2 px-4 text-sm mb-1">
                        <input type="checkbox" v-model="randomizeOptions" class="h-4 w-4 text-[#4787a4] rounded border-gray-300 mr-2">
                        <span>Opciones aleatorias</span>
                    </label>
                    
                    <!-- CAMBIO: Campo para seleccionar número de preguntas ahora es un SELECT -->
                    <label class="block text-gray-300 py-2 px-4 text-sm mt-4">
                        Número de preguntas:
                        <select v-model.number="numberOfQuestions" 
                                @change="resetQuiz" 
                                class="w-full mt-1 p-2 rounded bg-[#2d6073] text-white border border-[#3a738c] focus:outline-none focus:ring focus:border-[#4787a4]">
                            <!-- Genera opciones del 1 al número total de preguntas disponibles -->
                            <option v-for="n in allQuestions.length" :key="n" :value="n">{{ n }}</option>
                        </select>
                    </label>
                </div>
            </nav>
        </div>
        
        <!-- Main Content Area -->
        <div class="flex-1 min-h-screen flex flex-col">
            <!-- Header -->
            <header class="bg-[#4787a4] text-white shadow-md">
                <div class="container mx-auto px-4 py-6">
                    <h1 class="text-2xl md:text-3xl font-bold">Evaluación Interactiva</h1>
                    <p class="text-[#c2dce6]">Unidad 1: Introducción a las Redes de Computadoras</p>
            
                    <!-- Progress Bar -->
                    <div class="w-full bg-gray-200 rounded-full h-2.5 mt-4">
                        <div class="bg-[#5ea7c4] h-2.5 rounded-full transition-all duration-300" 
                             :style="{width: ((currentQuestionIndex + 1) / displayedQuestions.length * 100) + '%'}"></div>
                    </div>
                    <div class="flex justify-between text-sm mt-2">
                        <span>Pregunta {{ currentQuestionIndex + 1 }} de {{ displayedQuestions.length }}</span>
                        <span>{{ Math.round(((currentQuestionIndex + 1) / displayedQuestions.length) * 100) }}% Completado</span>
                        <span class="font-bold">Tiempo: {{ formatTime(elapsedTime) }}</span>
                    </div>
                </div>
            </header>

            <!-- Main Content -->
            <main class="container mx-auto px-4 py-8 flex-grow">
                <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                    <!-- Pregunta actual del quiz -->
                    <transition name="fade" mode="out-in">
                        <div v-if="!quizCompleted && currentQuestion" :key="currentQuestionIndex" class="question-container">
                            <h2 class="text-xl font-semibold mb-6">{{ currentQuestion.question }}</h2>
                            <p class="text-gray-600 text-sm mb-4">
                                <span v-if="currentQuestion.type === 'choice' && currentQuestion.multiple">Selecciona una o más opciones correctas.</span>
                                <span v-else-if="currentQuestion.type === 'choice'">Selecciona la opción correcta.</span>
                                <span v-else-if="currentQuestion.type === 'truefalse'">Selecciona Verdadero o Falso.</span>
                                <span v-else-if="currentQuestion.type === 'matching'">Relaciona cada término con su función principal.</span>
                            </p>
                    
                            <!-- Multiple Choice -->
                            <div v-if="currentQuestion.type === 'choice'" class="space-y-3">
                                <div v-for="(option, index) in currentQuestion.options" :key="index"
                                    class="p-4 border rounded-lg cursor-pointer transition-colors"
                                    :class="getOptionClass(option, index)">
                                    <label class="flex items-center cursor-pointer">
                                        <!-- Checkbox para múltiple selección -->
                                        <div v-if="currentQuestion.multiple" class="flex items-center">
                                            <input type="checkbox" 
                                                :checked="isOptionSelected(option, index)"
                                                @change="toggleOption(option, $event)"
                                                :disabled="quizSubmitted"
                                                class="h-5 w-5 text-[#4787a4] rounded border-gray-300 focus:ring-[#4787a4]">
                                            <span class="ml-3">{{ option.text }}</span>
                                        </div>
                                        <!-- Radio button para selección única -->
                                        <div v-else class="flex items-center">
                                            <input type="radio" 
                                                :checked="isOptionSelected(option, index)"
                                                @change="selectSingleOption(option, $event)"
                                                :name="'question-' + currentQuestionIndex"
                                                :disabled="quizSubmitted"
                                                class="h-5 w-5 text-[#4787a4] border-gray-300 focus:ring-[#4787a4]">
                                            <span class="ml-3">{{ option.text }}</span>
                                        </div>
                                    </label>
                                </div>
                            </div>

                            <!-- True/False -->
                            <div v-else-if="currentQuestion.type === 'truefalse'" class="space-y-3" role="radiogroup" :aria-labelledby="'question-' + currentQuestionIndex + '-title'">
                                <span :id="'question-' + currentQuestionIndex + '-title'" class="sr-only">{{ currentQuestion.question }}</span>
                                <div v-for="option in ['Verdadero', 'Falso']" :key="option"
                                    @click="selectSingleOption(option)"
                                    class="p-4 border rounded-lg cursor-pointer transition-colors"
                                    :class="getOptionClass(option)"
                                    :aria-checked="isOptionSelected(option) ? 'true' : 'false'"
                                    :aria-disabled="quizSubmitted ? 'true' : 'false'"
                                    role="radio">
                                    <div class="flex items-center">
                                        <div class="w-6 h-6 rounded-full border flex items-center justify-center mr-3 flex-shrink-0"
                                            :class="{
                                                'border-green-500': quizSubmitted && isOptionCorrect(option),
                                                'border-red-500': quizSubmitted && isOptionSelected(option) && !isOptionCorrect(option),
                                                'border-[#75b0c8]': !quizSubmitted && isOptionSelected(option), 
                                                'border-gray-300': !isOptionSelected(option) && !quizSubmitted 
                                            }">
                                            <div v-if="isOptionSelected(option)" 
                                                class="w-3 h-3 rounded-full"
                                                :class="{
                                                    'bg-green-500': quizSubmitted && isOptionCorrect(option),
                                                    'bg-red-500': quizSubmitted && !isOptionCorrect(option),
                                                    'bg-[#4787a4]': !quizSubmitted 
                                                }"></div>
                                            <div v-else-if="quizSubmitted && isOptionCorrect(option)" 
                                                 class="w-3 h-3 rounded-full bg-green-500"></div>
                                        </div>
                                        <span>{{ option }}</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Matching -->
                            <div v-else-if="currentQuestion.type === 'matching'" class="space-y-4">
                                <div v-for="(item, index) in currentQuestion.items" :key="index" class="flex items-center">
                                    <span class="w-1/3 font-medium">{{ item.term }}</span>
                                    <select v-model="userAnswers[currentQuestionIndex][index]" 
                                            @change="checkAnswer"
                                            class="flex-1 ml-4 p-2 border rounded"
                                            :class="{
                                                'bg-green-50 border-green-500': quizSubmitted && isMatchingCorrect(index),
                                                'bg-red-50 border-red-500': quizSubmitted && !isMatchingCorrect(index) && userAnswers[currentQuestionIndex][index],
                                                'bg-[#e0eef4] border-[#75b0c8]': !quizSubmitted && userAnswers[currentQuestionIndex][index] !== '' && userAnswers[currentQuestionIndex][index] !== undefined, 
                                                'border-gray-300': !userAnswers[currentQuestionIndex][index] 
                                            }"
                                            :disabled="quizSubmitted">
                                        <option value="">Selecciona una opción</option>
                                        <option v-for="(option, optIndex) in currentQuestion.options" 
                                                :key="optIndex" 
                                                :value="option"
                                                :disabled="isOptionUsed(option, index)">
                                            {{ option }}
                                        </option>
                                    </select>
                                </div>
                            </div>

                        <!-- Feedback -->
                        <div v-if="showFeedback" class="mt-6 p-4 rounded-lg" 
                             :class="isAnswerCorrect ? 'bg-green-50 text-green-700' : 'bg-red-50 text-red-700'"
                             role="status" aria-live="polite">
                            <p class="font-medium">
                                <i :class="isAnswerCorrect ? 'fas fa-check-circle' : 'fas fa-times-circle'" class="mr-2"></i>
                                {{ isAnswerCorrect ? '¡Correcto!' : 'Incorrecto' }}
                            </p>
                            <p class="mt-2" v-html="currentQuestion.explanation"></p>
                        </div>

                        <!-- Navigation Buttons -->
                        <div class="flex justify-between mt-8">
                            <button @click="previousQuestion" 
                                    :disabled="currentQuestionIndex === 0"
                                    class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg disabled:opacity-50"
                                    aria-label="Pregunta anterior">
                                <i class="fas fa-arrow-left mr-2"></i>Anterior
                            </button>
                            
                            <!-- Botón "Verificar Respuesta" para preguntas de selección múltiple -->
                            <button v-if="currentQuestion.type === 'choice' && currentQuestion.multiple && !quizSubmitted"
                                    @click="checkAnswer" 
                                    :disabled="!isAnswerSelected"
                                    class="px-6 py-2 bg-[#4787a4] text-white rounded-lg disabled:opacity-50 hover:bg-[#3a738c] transition-colors"
                                    aria-label="Verificar mi respuesta">
                                Verificar Respuesta<i class="fas fa-check ml-2"></i>
                            </button>

                            <!-- Botón "Siguiente" / "Finalizar" (AHORA SIEMPRE DEPENDE DE `quizSubmitted`) -->
                            <button v-else-if="!isLastQuestion" 
                                    @click="nextQuestion" 
                                    :disabled="!isAnswerSelected || !quizSubmitted"
                                    class="px-6 py-2 bg-[#4787a4] text-white rounded-lg disabled:opacity-50 hover:bg-[#3a738c] transition-colors"
                                    aria-label="Siguiente pregunta">
                                Siguiente<i class="fas fa-arrow-right ml-2"></i>
                            </button>

                            <button v-else 
                                    @click="submitQuiz" 
                                    :disabled="!isAnswerSelected || !quizSubmitted"
                                    class="px-6 py-2 bg-green-600 text-white rounded-lg disabled:opacity-50 hover:bg-green-700 transition-colors"
                                    aria-label="Finalizar evaluación">
                                Finalizar<i class="fas fa-check ml-2"></i>
                            </button>
                        </div>
                    </div>

                    <!-- Resultados del quiz (resto del HTML es el mismo) -->
                    <div v-else class="text-center py-8">
                        <div class="w-24 h-24 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-6">
                            <i class="fas fa-trophy text-4xl text-yellow-500"></i>
                        </div>
                        <h2 class="text-2xl font-bold mb-2">¡Evaluación Completada!</h2>
                        <p class="text-gray-600 mb-6">Has completado la evaluación de la Unidad 1</p>
                        
                        <div class="bg-[#e0eef4] p-6 rounded-lg max-w-md mx-auto mb-8">
                            <div class="text-4xl font-bold text-[#4787a4] mb-2">{{ score }}%</div>
                            <div class="w-full bg-gray-200 rounded-full h-4 mb-2">
                                <div class="bg-[#4787a4] h-4 rounded-full" 
                                    :style="{width: score + '%'}"></div>
                            </div>
                            <p class="text-sm text-gray-600">
                                {{ correctAnswersCount }} de {{ displayedQuestions.length }} respuestas correctas
                            </p>
                            <p class="text-sm text-gray-600 mt-2">
                                Tiempo total: {{ formatTime(elapsedTime) }}
                            </p>
                        </div>

                        <!-- Resumen detallado de respuestas -->
                        <div class="space-y-4 max-w-md mx-auto text-left mb-8">
                            <h3 class="font-semibold text-lg text-center mb-4">Resumen de respuestas:</h3>
                            <div v-for="(question, index) in displayedQuestions" :key="index" 
                                 class="p-4 border rounded-lg"
                                 :class="isQuestionCorrect(index) ? 'border-green-200 bg-green-50' : 'border-red-200 bg-red-50'">
                                <div class="flex items-start">
                                    <div class="flex-shrink-0 mt-1">
                                        <i v-if="isQuestionCorrect(index)" 
                                           class="fas fa-check-circle text-green-500 text-xl"></i>
                                        <i v-else 
                                           class="fas fa-times-circle text-red-500 text-xl"></i>
                                    </div>
                                    <div class="ml-3">
                                        <h3 class="font-medium">Pregunta {{ index + 1 }}: {{ question.question }}</h3>
                                        <p v-if="!isQuestionCorrect(index)" class="text-sm text-gray-600 mt-1">
                                            <span class="font-medium">Respuesta correcta:</span> 
                                            <span v-if="question.type === 'truefalse'">
                                                {{ question.correctAnswer }}
                                            </span>
                                            <span v-else-if="question.type === 'choice' && !question.multiple">
                                                {{ question.options.find(opt => opt.correct)?.text }}
                                            </span>
                                            <span v-else-if="question.type === 'choice' && question.multiple">
                                                {{ question.options.filter(opt => opt.correct).map(opt => opt.text).join(', ') }}
                                            </span>
                                            <span v-else-if="question.type === 'matching'">
                                                <ul class="list-disc pl-5">
                                                    <li v-for="(item, i) in question.items" :key="i">
                                                        {{ item.term }}: {{ item.correct }}
                                                    </li>
                                                </ul>
                                            </span>
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="mt-8 flex justify-center">
                            <button @click="resetQuiz" 
                                    class="px-6 py-3 bg-[#4787a4] text-white rounded-lg hover:bg-[#3a738c] transition-colors"
                                    aria-label="Reiniciar cuestionario">
                                Reiniciar cuestionario
                            </button>
                        </div>
                    </div>
                </div>
            </main>

            <!-- Footer -->
            <footer class="bg-gray-800 text-white py-6 mt-auto">
                <div class="container mx-auto px-4 text-center">
                    <p>© 2025 Escuela Superior Politécnica Agropecuaria de Manabí Manuel Félix López</p>
                    <p class="text-gray-400 text-sm mt-1">Carrera de Computación - Mgtr. Joffre Moreira Pico</p>
                </div>
            </footer>
        </div>
    </div>

        <!-- Cargar dependencias -->
    <script src="https://cdn.jsdelivr.net/npm/vue@3.2.47/dist/vue.global.min.js"></script>
    <!-- Cargar las preguntas desde un archivo externo -->
    <script src="public/questions1.js"></script> 
    <script>
        const { createApp, ref, computed, onMounted, nextTick, watch } = Vue; 

        // Usar las preguntas cargadas desde questions.js
        const allQuestions = window.quizQuestions || [];
        
        if (allQuestions.length === 0) {
            console.error('No se pudieron cargar las preguntas. Verifica que el archivo public/questions1.js esté correctamente configurado y asigne las preguntas a window.quizQuestions.');
        }

        // Crear la aplicación Vue
        const app = createApp({
            setup() {
                // Configuración de usuario
                const randomizeQuestions = ref(localStorage.getItem('randomizeQuestions') === 'true');
                const randomizeOptions = ref(localStorage.getItem('randomizeOptions') === 'true');
                
                // NUEVO: Número de preguntas a mostrar
                const storedNumQuestions = parseInt(localStorage.getItem('numberOfQuestions'));
                // Si no hay valor guardado, o es inválido, usar el total de preguntas disponibles por defecto
                const initialNumQuestions = (isNaN(storedNumQuestions) || storedNumQuestions < 1 || storedNumQuestions > allQuestions.length) 
                                            ? allQuestions.length 
                                            : storedNumQuestions;
                const numberOfQuestions = ref(initialNumQuestions);

                // Estado del quiz
                const displayedQuestions = ref([]); // Array de preguntas actual, puede ser aleatorio
                const currentQuestionIndex = ref(0);
                const userAnswers = ref([]); // Almacena las respuestas del usuario
                const quizSubmitted = ref(false); // Indica si la pregunta actual ha sido "evaluada"
                const quizCompleted = ref(false); 
                const showFeedback = ref(false); // Controla la visibilidad del feedback de la pregunta actual
                const isAnswerCorrect = ref(false); // Resultado del feedback de la pregunta actual

                // Estado del temporizador
                const quizStartTime = ref(0); 
                const elapsedTime = ref(0);
                let timerInterval = null;

                // Watchers para guardar configuración en localStorage
                watch(randomizeQuestions, (newValue) => {
                    localStorage.setItem('randomizeQuestions', newValue);
                    resetQuiz(); // Reiniciar el quiz si cambia la configuración
                });
                watch(randomizeOptions, (newValue) => {
                    localStorage.setItem('randomizeOptions', newValue);
                    resetQuiz(); // Reiniciar el quiz si cambia la configuración
                });
                // NUEVO Watcher para numberOfQuestions
                watch(numberOfQuestions, (newValue) => {
                    localStorage.setItem('numberOfQuestions', newValue);
                    resetQuiz(); // Reiniciar el quiz si cambia el número de preguntas
                });


                // Propiedades computadas
                const currentQuestion = computed(() => {
                    if (!displayedQuestions.value || displayedQuestions.value.length === 0) {
                        return null; 
                    }
                    return displayedQuestions.value[currentQuestionIndex.value];
                });
                
                const isLastQuestion = computed(() => currentQuestionIndex.value === displayedQuestions.value.length - 1);
                
                const isAnswerSelected = computed(() => {
                    const currentAns = userAnswers.value[currentQuestionIndex.value];
                    const qType = currentQuestion.value?.type; 

                    if (qType === 'choice' && currentQuestion.value.multiple) {
                        return Array.isArray(currentAns) && currentAns.length > 0;
                    } else if (qType === 'choice' || qType === 'truefalse') {
                        return currentAns !== null && currentAns !== undefined;
                    } else if (qType === 'matching') {
                        const numItems = currentQuestion.value.items.length;
                        const selectedAnswers = currentAns || {}; 
                        const numSelected = Object.keys(selectedAnswers).length;

                        return numSelected === numItems && Object.values(selectedAnswers).every(val => val !== '' && val !== null && val !== undefined);
                    }
                    return false;
                });

                const score = computed(() => {
                    if (displayedQuestions.value.length === 0) return 0;
                    return Math.round((correctAnswersCount.value / displayedQuestions.value.length) * 100);
                });
                
                const correctAnswersCount = computed(() => {
                    return displayedQuestions.value.reduce((count, _, index) => {
                        return count + (isQuestionCorrect(index) ? 1 : 0);
                    }, 0);
                });

                // Métodos auxiliares
                function shuffleArray(array) {
                    const newArray = [...array]; 
                    for (let i = newArray.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
                    }
                    return newArray;
                }

                function formatTime(seconds) {
                    const minutes = Math.floor(seconds / 60);
                    const remainingSeconds = seconds % 60;
                    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
                }

                // Lógica del temporizador
                function startTimer() {
                    if (timerInterval) clearInterval(timerInterval);
                    timerInterval = setInterval(() => {
                        elapsedTime.value++;
                    }, 1000);
                }

                function stopTimer() {
                    if (timerInterval) {
                        clearInterval(timerInterval);
                        timerInterval = null;
                    }
                }

                // Lógica de carga/guardado de progreso
                function saveProgress() {
                    try {
                        const progress = {
                            currentQuestionIndex: currentQuestionIndex.value,
                            userAnswers: userAnswers.value,
                            quizCompleted: quizCompleted.value,
                            elapsedTime: elapsedTime.value,
                            displayedQuestionIds: displayedQuestions.value.map(q => q.id), 
                            randomizeQuestions: randomizeQuestions.value, 
                            randomizeOptions: randomizeOptions.value,
                            numberOfQuestions: numberOfQuestions.value 
                        };
                        localStorage.setItem('quizProgress', JSON.stringify(progress));
                    } catch (e) {
                        console.error("Error al guardar el progreso:", e);
                    }
                }

                function loadProgress() {
                    try {
                        const savedProgress = localStorage.getItem('quizProgress');
                        if (savedProgress) {
                            const progress = JSON.parse(savedProgress);
                            
                            // Verificar si las configuraciones de aleatorización o número de preguntas han cambiado
                            const configChanged = (progress.randomizeQuestions !== randomizeQuestions.value ||
                                                   progress.randomizeOptions !== randomizeOptions.value ||
                                                   progress.numberOfQuestions !== numberOfQuestions.value); 

                            if (configChanged || !progress.displayedQuestionIds || progress.displayedQuestionIds.length === 0) {
                                console.log("Configuración de quiz cambiada o progreso inválido. Iniciando quiz nuevo.");
                                initializeQuizQuestions(true); 
                                startTimer();
                                return; 
                            }

                            currentQuestionIndex.value = progress.currentQuestionIndex;
                            userAnswers.value = progress.userAnswers;
                            quizCompleted.value = progress.quizCompleted; 
                            elapsedTime.value = progress.elapsedTime;
                            
                            // Asegurarse de que numberOfQuestions refleje el progreso cargado para la próxima vez que se inicie el quiz
                            // y que esté dentro de los límites válidos
                            let loadedNumQuestions = progress.numberOfQuestions;
                            if (loadedNumQuestions > allQuestions.length) loadedNumQuestions = allQuestions.length;
                            if (loadedNumQuestions < 1) loadedNumQuestions = 1;
                            numberOfQuestions.value = loadedNumQuestions;
                            
                            displayedQuestions.value = progress.displayedQuestionIds
                                .map(id => allQuestions.find(q => q.id === id))
                                .filter(q => q); 

                            if (!quizCompleted.value) {
                                startTimer();
                            } else {
                                stopTimer();
                            }
                            console.log("Progreso cargado con éxito.");
                        } else {
                            initializeQuizQuestions(true); 
                            startTimer();
                        }
                    } catch (e) {
                        console.error("Error al cargar el progreso:", e);
                        initializeQuizQuestions(true);
                        startTimer();
                    }
                }

                function initializeQuizQuestions(resetAnswers = false) {
                    let tempQuestions = [...allQuestions];
                    if (randomizeQuestions.value) {
                        tempQuestions = shuffleArray(tempQuestions);
                    }
                    
                    // Limitar el número de preguntas a mostrar
                    // Asegurarse de que numberOfQuestions no exceda el total disponible, ni sea menor que 1
                    const numToDisplay = Math.min(Math.max(1, numberOfQuestions.value), tempQuestions.length);
                    
                    displayedQuestions.value = tempQuestions.slice(0, numToDisplay).map(q => { 
                        let newQ = { ...q };
                        if (newQ.type === 'choice' && randomizeOptions.value && newQ.options) {
                            newQ.options = shuffleArray(newQ.options);
                        }
                        if (newQ.type === 'matching' && randomizeOptions.value && newQ.options) {
                            newQ.options = shuffleArray(newQ.options);
                        }
                        return newQ;
                    });
                    
                    if (resetAnswers) {
                        userAnswers.value = Array(displayedQuestions.value.length).fill(null).map((_, idx) => {
                            const q = displayedQuestions.value[idx];
                            if (q.type === 'matching') {
                                const initialMatchingAnswers = {};
                                q.items.forEach((_, itemIdx) => { initialMatchingAnswers[itemIdx] = ''; });
                                return initialMatchingAnswers;
                            } else if (q.type === 'choice' && q.multiple) {
                                return [];
                            } else {
                                return null;
                            }
                        });
                    }
                }


                // Lógica de las preguntas
                function isOptionCorrect(option) {
                    const question = currentQuestion.value;
                    if (question?.type === 'choice') { 
                        return option.correct === true;
                    } else if (question?.type === 'truefalse') { 
                        return option === question.correctAnswer;
                    }
                    return false;
                }

                function getOptionClass(option, index) {
                    const isSelected = isOptionSelected(option, index);
                    
                    if (!quizSubmitted.value) {
                        return isSelected 
                            ? 'bg-[#e0eef4] border-[#75b0c8]' 
                            : 'hover:bg-gray-50';
                    }
                    
                    const isCorrect = isOptionCorrect(option); 
                    if (isCorrect) {
                        return isSelected ? 'bg-green-100 border-green-500' : 'bg-green-50 border-green-300';
                    } else if (isSelected) {
                        return 'bg-red-50 border-red-500';
                    }
                    
                    return 'bg-gray-50';
                }

                function isOptionSelected(option, index) {
                    const currentAnswer = userAnswers.value[currentQuestionIndex.value];
                    if (currentAnswer === null || currentAnswer === undefined) return false;
                    
                    const question = currentQuestion.value;

                    if (question?.type === 'choice') { 
                        if (question.multiple) {
                            return Array.isArray(currentAnswer) && 
                                   currentAnswer.some(ans => ans && ans.text === option.text);
                        } else {
                            return currentAnswer && currentAnswer.text === option.text;
                        }
                    } else if (question?.type === 'truefalse') { 
                        return currentAnswer === option;
                    } else if (question?.type === 'matching' && index !== undefined) { 
                        return currentAnswer[index] !== undefined && currentAnswer[index] === option;
                    }
                    return false;
                }

                function toggleOption(option, event) {
                    const currentAnswer = userAnswers.value[currentQuestionIndex.value] || [];
                    const optionIndex = currentAnswer.findIndex(ans => ans && ans.text === option.text);
                    
                    if (optionIndex === -1) {
                        userAnswers.value[currentQuestionIndex.value] = [...currentAnswer, option];
                    } else {
                        const newAnswers = [...currentAnswer];
                        newAnswers.splice(optionIndex, 1);
                        userAnswers.value[currentQuestionIndex.value] = newAnswers;
                    }
                    saveProgress(); 
                }

                function selectSingleOption(option, event) {
                    userAnswers.value[currentQuestionIndex.value] = option;
                    checkAnswer(); 
                }

                function checkAnswer() {
                    const question = currentQuestion.value;
                    const userAnswer = userAnswers.value[currentQuestionIndex.value];

                    let currentQIsCorrect = false; 

                    if (!isAnswerSelected.value) { 
                        showFeedback.value = false;
                        quizSubmitted.value = false;
                        isAnswerCorrect.value = false; 
                        return;
                    }

                    if (question.type === 'choice' && question.multiple) {
                        const selectedOptions = userAnswer || [];
                        const correctOptions = question.options.filter(opt => opt.correct);
                        
                        const allCorrectSelected = correctOptions.every(opt => 
                            selectedOptions.some(sel => sel && sel.text === opt.text)
                        );
                        const noIncorrectSelected = selectedOptions.every(sel => 
                            correctOptions.some(opt => opt.text === (sel?.text || sel))
                        );
                        
                        currentQIsCorrect = allCorrectSelected && noIncorrectSelected && selectedOptions.length === correctOptions.length;

                    } else if (question.type === 'choice' && !question.multiple) {
                        currentQIsCorrect = userAnswer?.correct === true;
                    } else if (question.type === 'truefalse') {
                        currentQIsCorrect = userAnswer === question.correctAnswer;
                    } else if (question.type === 'matching') {
                        const currentAnswers = userAnswer;
                        currentQIsCorrect = Object.entries(currentAnswers || {}).every(([index, answer]) => {
                            return answer === question.items[parseInt(index)].correct; 
                        }) && Object.keys(currentAnswers).length === question.items.length; 
                    }

                    isAnswerCorrect.value = currentQIsCorrect; 

                    nextTick(() => {
                        showFeedback.value = true;
                        quizSubmitted.value = true;

                        console.log(`[checkAnswer Debug] Q${currentQuestionIndex.value + 1} (${question.type}): ` +
                                    `User Answer:`, JSON.stringify(userAnswers.value[currentQuestionIndex.value]),
                                    `| isAnswerSelected (computed): ${isAnswerSelected.value}, ` +
                                    `| quizSubmitted: ${quizSubmitted.value}, ` +
                                    `| isAnswerCorrect: ${isAnswerCorrect.value}`);
                        saveProgress(); 
                    });
                }

                function nextQuestion() {
                    if (currentQuestionIndex.value < displayedQuestions.value.length - 1) {
                        currentQuestionIndex.value++;
                        showFeedback.value = false;
                        quizSubmitted.value = false;
                        isAnswerCorrect.value = false; 
                    }
                    saveProgress();
                }

                function previousQuestion() {
                    if (currentQuestionIndex.value > 0) {
                        currentQuestionIndex.value--;
                        showFeedback.value = false;
                        quizSubmitted.value = false;
                        isAnswerCorrect.value = false; 
                    }
                    saveProgress();
                }

                function submitQuiz() {
                    if (!quizSubmitted.value) { 
                        checkAnswer(); 
                    }
                    quizCompleted.value = true;
                    stopTimer();
                    saveProgress(); 
                }

                function resetQuiz() {
                    stopTimer();
                    currentQuestionIndex.value = 0;
                    quizSubmitted.value = false;
                    quizCompleted.value = false;
                    showFeedback.value = false;
                    isAnswerCorrect.value = false; 
                    elapsedTime.value = 0;
                    localStorage.removeItem('quizProgress'); 
                    
                    initializeQuizQuestions(true); 
                    startTimer();
                    saveProgress(); 
                }

                function isMatchingCorrect(index) {
                    if (!quizSubmitted.value) return false;
                    const userAnswer = userAnswers.value[currentQuestionIndex.value]?.[index];
                    return userAnswer !== undefined && userAnswer !== '' && 
                           currentQuestion.value.items[parseInt(index)] && userAnswer === currentQuestion.value.items[parseInt(index)].correct; 
                }
                
                function isOptionUsed(option, currentIndex) {
                    const currentAnswers = userAnswers.value[currentQuestionIndex.value] || {};
                    return Object.entries(currentAnswers)
                        .some(([idx, ans]) => parseInt(idx) !== currentIndex && ans === option);
                }

                function isQuestionCorrect(questionIndex) {
                    const question = displayedQuestions.value[questionIndex];
                    const answer = userAnswers.value[questionIndex];

                    if (!question || !answer) return false; 

                    if (question.type === 'choice') {
                        if (question.multiple) {
                            const selectedOptions = answer || [];
                            const correctOptions = question.options.filter(opt => opt.correct);

                            const allCorrectSelected = correctOptions.every(opt =>
                                selectedOptions.some(sel => sel && sel.text === opt.text)
                            );
                            const noIncorrectSelected = selectedOptions.every(sel =>
                                correctOptions.some(opt => opt.text === (sel?.text || sel))
                            );

                            return allCorrectSelected && noIncorrectSelected && selectedOptions.length === correctOptions.length;
                        } else {
                            return answer?.correct === true;
                        }
                    } else if (question.type === 'truefalse') {
                        return answer === question.correctAnswer;
                    } else if (question.type === 'matching') {
                        const currentMatchingAnswers = answer || {};
                        return question.items.every((item, index) => 
                            currentMatchingAnswers[index] === item.correct 
                        ) && Object.keys(currentMatchingAnswers).length === question.items.length && Object.values(currentMatchingAnswers).every(val => val !== '' && val !== null && val !== undefined); 
                    }
                    return false;
                }

                // Cargar progreso o iniciar quiz al montar el componente
                onMounted(() => {
                    loadProgress();
                    window.addEventListener('beforeunload', saveProgress);
                });

                // Devolver propiedades y métodos para la plantilla
                return {
                    randomizeQuestions,
                    randomizeOptions,
                    numberOfQuestions, 
                    displayedQuestions,
                    currentQuestionIndex,
                    userAnswers,
                    quizSubmitted,
                    quizCompleted,
                    showFeedback,
                    isAnswerCorrect,
                    currentQuestion,
                    isLastQuestion,
                    isAnswerSelected,
                    score,
                    elapsedTime,
                    correctAnswersCount,
                    allQuestions, 
                    
                    formatTime,
                    toggleOption,
                    selectSingleOption,
                    checkAnswer, 
                    nextQuestion,
                    previousQuestion,
                    submitQuiz,
                    resetQuiz,
                    isOptionSelected,
                    isOptionCorrect,
                    getOptionClass,
                    isMatchingCorrect,
                    isOptionUsed,
                    isQuestionCorrect,
                };
            }
        }).mount('#app');
    </script>
</body>
</html>